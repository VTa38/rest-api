# rest-api
При переходе по ссылке “/” выводится текст: Main operations with the file occur under the "/files" link 
Если послать post запрос по ссылке “/files”
 ![image](https://user-images.githubusercontent.com/67002782/174655424-a2f77f16-5807-48c3-858c-be4d2cb39e46.png)


Первое, что произойдёт это проверка файла, если файл не в формате .txt, то выведется текст: Text must have .txt format. А так же у запроса будет статус: 415 Unsupported Media Type.


В случае если файл нужного формата, создастся ответ на запрос, в котором будет название загруженного файла(String), его размер(int) и структура навигации(List<NavigationDTO>):
 ![image](https://user-images.githubusercontent.com/67002782/174655463-0d3c0503-869e-4df4-8d69-ff2f1f7bbed3.png)



Далее try блок, в котором будет проходить основные преобразования. Структура сразу записывается в класс ответа:
![image](https://user-images.githubusercontent.com/67002782/174655482-ea302351-45f5-44bc-ad96-2a447514d1e0.png)



Сначала файл разобьётся на строки, в классе FileParser. FileParser ничего не знает о файле и правильной структуре, он только разбивает файл на строки и возвращает List<Srting>.
 ![image](https://user-images.githubusercontent.com/67002782/174655498-c68697b0-e542-4553-b304-51231128dc9f.png)


Затем полученная в результате работы FileParser коллекция отправляется в FileAnalyzer, в котором происходит основная логика. FileAnalyzer вернёт List<NavigationDTO> это объект, хранящий в себе ссылку на вышестоящую по иерархии строку, саму строку, уровень вложенности и лист строк, которые вложены в неё:
 ![image](https://user-images.githubusercontent.com/67002782/174655513-dab4b61b-4b4f-4f56-a7f4-64d8e3511cfe.png)
Методы этого класса простые геттеры и сеттеры на каждое поле, за исключением 2х из них:
	- Сеттер на лист вложенных строк добавляет NavigationDTO по одному
	- Геттер на вышестоящий объект имеет default модификатор доступа, чтобы из контроллеров не было доступа к этому полю.


В FileAnalyzer после объявления возвращаемой коллекции создаются 2 объекта NavigationDTO. Один из них не инициализируется, так как будет являться вышестоящей структурой, без завершённой вложенности:
  ![image](https://user-images.githubusercontent.com/67002782/174655546-250b2b9a-045a-4009-a467-9fe42b3b44ba.png)


Далее начинается итерация по всем входным строкам 
Первое, на что проверяется строка это на то, была ли она разбита переносом “CRLF”, ”LF”, ”CR”
 ![image](https://user-images.githubusercontent.com/67002782/174655561-9fe3e307-8b8b-42f1-9e1c-87ac3e55da46.png)
Если после между частями разорванной строки возникает ‘#’, означающая уровень вложенности, например:
Hello, my CRLF
#name is Victor
Будет выброшенно исключение, означающее неправильную структуру входного файла.
![image](https://user-images.githubusercontent.com/67002782/174655577-871e7471-deb0-4e58-8847-c2f0c46cbbeb.png)


Далее идёт определение уровня вложенности с помощью приватного метода checkLevel, запись уровня в текущий объект и проверка структуры на скачок уровня вложенности(после строки с уровнем вложенности N не может идти строка с уровнем вложенности N+2 или больше) и на то, чтобы 1й элемент не был вложен, это невозможно. В случае ошибки они бросают исключение, означающее неправильную структуру.
 

Метод сheckLevel:
![image](https://user-images.githubusercontent.com/67002782/174655631-ebb12b3b-3778-45d1-b986-c7ac5d651d3f.png)


Дальше идёт обработка корневых строк (строк с уровне вложенности 0). У них не будет родителя, поэтому setParent(null), записывается текущая строка и сам объект записывается в результирующий лист.
![image](https://user-images.githubusercontent.com/67002782/174655679-6b073410-deb5-4cf7-a447-f17dea9fd46d.png)


Если же строка имеет не нулевой уровень вложенности она переходит в блок else, в котором её уровень вложенности сравнивается с уровнем предшествующей строки(1я строка не сможет войти в этот блок, поэтому не возникнет такой ситуации, что предшествующей строки не существует).
В случае если уровень вложенности строки меньше или равен уровню предшественника, то есть строка стоит выше или стоит на ране с предыдущей строкой, предыдущая строка перезаписывается на своего родителя, и проверка начинается вновь пока не буде найден родитель текущей строки.
 ![image](https://user-images.githubusercontent.com/67002782/174655711-b5862bf5-ac3b-4a46-a590-56b8b7a2dc08.png)
Текущая строка записывает себе ссылку на родителя, записывает текущую строку как свою. В этом алгоритме вложенные строки ищут свою строку-родителя, поэтому после того, как они её наши родитель записывает текущую строку с список своих вложенностей.
Файл прошёл все этапы и если не возникло исключений, которые обрабатываются в контроллере, выведется ответ с небольшой информацией о входном файле(его названием и размеров) и структурой для создания навигации.
![image](https://user-images.githubusercontent.com/67002782/174655725-08dbf3b5-13b0-469f-8e58-4625ab6cf790.png)
 
                      Пример
   Файл с записями:
String0
#String1
##String2CR
+some string
##String2
#String1
##String2CRLF
+some string
#String1
##String2
###String3LF
+some string
####String4
##String2

	Преобразуется в Json вида:
{
    "fileName": "NormalData.txt",
    "fileSize": 169,
    "structure": [
        {
            "line": "String0",
            "level": 0,
            "navigation": [
                {
                    "line": "String1",
                    "level": 1,
                    "navigation": [
                        {
                            "line": "String2+some string",
                            "level": 2,
                            "navigation": []
                        },
                        {
                            "line": "String2",
                            "level": 2,
                            "navigation": []
                        }
                    ]
                },
                {
                    "line": "String1",
                    "level": 1,
                    "navigation": [
                        {
                            "line": "String2+some string",
                            "level": 2,
                            "navigation": []
                        }
                    ]
                },
                {
                    "line": "String1",
                    "level": 1,
                    "navigation": [
                        {
                            "line": "String2",
                            "level": 2,
                            "navigation": [
                                {
                                    "line": "String3+some string",
                                    "level": 3,
                                    "navigation": [
                                        {
                                            "line": "String4",
                                            "level": 4,
                                            "navigation": []
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "line": "String2",
                            "level": 2,
                            "navigation": []
                        }
                    ]
                }
            ]
        }
    ]
}
